The file should include the information listed below, answering all the questions in each category.

    Division of labor (1-2 paragraphs)
    An explanation of how you split the work for this assignment among members of your team, and why you split it this way.

    Design (1-3 pages)
    A description of the overall organization of your submitted program—algorithms and data structures—that lists operations on blocks, trays, and the collection of trays seen earlier in the solution search. Diagrams will be useful here to show the correspondence between an abstract tray and your tray implementation. This description should contain enough detail for another CS 61BL student to understand clearly how the corresponding code would work.

    /*
    
    We began the process by thoroughly reading the project descriptions and understanding the internal structure of the input and goal files. As part of this process, we designed a few sample boards and goals ourselves and created a rudimentary Solver test class that would simply print our hand-written solutions so that we could test whether or not our intuition with regards to the program setup was correct.
    
    
    (1) 
    - read configuration files
    
    
    (2) 
    - intialize boards & store configuration
    
    (2.1)
    - validate size. i.e. do pieces "fit" on the board
    
    
    BOARD
    - storage of individual pieces as array
    - dimensions
    -is valid board
    - possible moves (iterator?)
    - toString
    
    
    
    SOLVER
    - hashset to keep track of seen boards
    - main iteration method to traverse through all possible configureation
    - isGoal to check if a given config is "done"
    - keeping track of different pathways to be able to present solution
    
    - one-space moves for now
    - consideration of various "special" scenarios
    
            
    (3)
    - check if goal is reached; if not, 
    - manipulate the initial configuration of the board by making a legal move & keep track of the moves
    
    
    
    */

    Debugging (2-4 paragraphs)
    Description of your debugging output facility and how to enable it, plus a description of your isOK method, and how useful they were in revealing program bugs.

    Evaluating tradeoffs (1-2 pages per experiment)
    Three experiments comparing results of a design choice from the project. Each experiment should include the following sections and content, written in a way that a fellow CS 61BL student would understand:
        Summary: 2-3 sentence description of the test and the result
        Methods: Details of the test
        Results: Graphs or tables with the results of the test
        Conclusions: Explanation and interpretation of the results

    Here are some questions to get you thinking about appropriate tests. One of your three experiments must address the choice of data structures listed first in the list below.
        What data structures choices did you consider for the tray? What operations did you optimize: fast generation of possible moves, fast comparison of the current configuration with the goal, or making a move? How did these considerations conflict? This must be one of your three experiments.
        How did you choose a hash function for trays? How did your choice optimize the need for fast computation, minimal collisions, and economical use of memory?
        How did you choose between moving blocks one square at a time and making longer block moves?
        How did you choose between breadth-first and depth-first processing of the tree of move sequences? If you took a different approach, what was it and why did you take the approach?

    Disclaimers (1-3 paragraphs)
    In this section, describe parts of the project that don't work. Also, if you were to make one more improvement to speed up the program, what would it be, and what is your evidence for expecting a significant speedup?

    Program development (a page or so)
    An explanation of the process by which you constructed a working program:
        What did you code and test first, and what did you postpone?
        Why did you build the program in this sequence?
        What test cases did you use for each of your classes, and how did you choose them?

In general, comments in your code will describe information specific to the corresponding class, while the readme file contains information that relates classes and describes and provides rationale for design and implementation decisions. However, your readme file should be written to be read on its own without a copy of the program code at hand, so there may be some information duplicated in writeup and code.
